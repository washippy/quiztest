 package {        import flash.events.*		import flash.display.*	import flash.display.SimpleButton;	import com.greensock.TweenLite; 	    dynamic public class Quiz extends MovieClip{			private var ORANGE:slice1flip;		private var BLUE:slice2flip;		private var RED:slice3flip;		private var YELLOW:slice4flip;		private var PURPLE:slice5flip;		private var GREEN:slice6flip;				private var TF_Q:tf_question;		private var MC_Q:mc_question;		private var container:Sprite;		private var sNum:Number;  // spin / topic number / spin #1 gets SPIN_ARRAY[0] (shuffled)		private var qNum:Number;  // quiz number >> first time thru the quiz yeilds first question in each (shuffled) array			private var _quizObject:Array;			public static const GO:String = "go";				private var QUESTIONTYPE:String;		private var HOLD_CLICKED_ANSWER:String;		private var HOLD_CORRECT_ANSWER:String;				private var HOTCLIP:MovieClip;		// container.removeChild(DisplayObject(event.target)); 		/* METRIX			flmc: finance tools: wheel game: start			flmc: finance tools: wheel game: question: <question>			flmc: finance tools: wheel game: thank you			flmc: finance tools: wheel game: thank you: print				*/				public function set dataObj(yup:Object) { 			_quizObject = yup;			trace("YUP" + _quizObject);		}				public function get dataObj() { 			return _quizObject;		}	        public function Quiz(){			trace("HEEEYY QUIZ ME " );			ORANGE = new slice1flip();			BLUE = new slice2flip();			RED = new slice3flip();			YELLOW = new slice4flip();			PURPLE = new slice5flip();			GREEN = new slice6flip();			TF_Q = new tf_question();			MC_Q = new mc_question();	  		container = new Sprite();			addChild(container);						this.addEventListener(TimeLineEvent.GO, onListener);					}			public function fireitUP(_qN:Number,_sN:Number):void{			qNum = _qN;			sNum = _sN;			trace("FIRED UP" + sNum);			if(container.numChildren>0){				container.removeChildAt(0);			}		//	container.x = 90;		//	container.y = 147;			switch(sNum){				case 1 :				case 7 :						container.addChild(ORANGE);						ORANGE.gotoAndPlay(3);						//ORANGE.alpha=.5						getAQuestion();				break;								case 2 :				case 8 :					container.addChild(BLUE)										BLUE.gotoAndPlay(3);					//BLUE.alpha=.5					getAQuestion();				break;								case 3 :				case 9 :					container.addChild(RED)					RED.gotoAndPlay(3);					//RED.alpha=.5					getAQuestion();				break;								case 4 :				case 10 :					container.addChild(YELLOW)					YELLOW.gotoAndPlay(3);				//	YELLOW.alpha=.5					getAQuestion();				break;								case 5 :				case 11 :					container.addChild(PURPLE)					PURPLE.gotoAndPlay(3);				//	PURPLE.alpha=.5					getAQuestion();				break;								case 6 :				case 12 :					container.addChild(GREEN)					GREEN.gotoAndPlay(3);				//	GREEN.alpha=.5					getAQuestion();				break;			}		}				public function getAQuestion():void{			trace("getAQuestion 1 " + sNum);			trace("getAQuestion 2 " + qNum);			trace("getAQuestion 3 " + _quizObject);			trace("getAQuestion 4 " + _quizObject[0].topicNum);			//trace("getAQuestion 5 " + _quizArray[0].q_Arr[0].q_text);			sNum = sNum-1; // ARRAY ZEROED			qNum = qNum-1; // ARRAY ZEROED			trace("getAQuestion 6 "+_quizArray[sNum]);//.q_Arr[qN].q_type);			trace("getAQuestion 7 "+_quizArray[sNum].q_Arr[qNum]);			trace("getAQuestion 8 "+_quizArray[sNum].q_Arr[qNum].q_type);			//trace("GET A Q +"+_quizArray[sNum].topicNum); 						//getAQuestion 5		//	getAQuestion 1		//	GET A Q +6										//	addChild(MC_Q);				var sendme:String = _quizArray[sNum].q_Arr[qNum].q_type;			switch(sendme){				case "TF" :				trace("GET A Q MC 1");					QUESTIONTYPE ="TF";					addTFQuestion();				break;				case "MC" :				trace("GET A Q MC 2");					QUESTIONTYPE="MC";					addMCQuestion();				break;			}		}				private function addTFQuestion():void{			if(container.contains(MC_Q)){				container.removeChild(MC_Q);								}			if(contains(TF_Q)){				container.removeChild(TF_Q);			}			container.addChild(TF_Q);			HOTCLIP= TF_Q;			TF_Q.alpha=0;			TF_Q.x = 90;			TF_Q.y = 147;			TF_Q.true_b.CORRECT = _quizArray[sNum].q_Arr[qNum].q_choicearray[0].surveysays;			TF_Q.false_b.CORRECT = _quizArray[sNum].q_Arr[qNum].q_choicearray[1].surveysays;						setEvents(TF_Q.true_b);			setEvents(TF_Q.false_b);					}						function onListener(e:TimeLineEvent):void {			trace("ANIMATION FINISHED");			trace(container.getChildAt(1).name);			var fadeMeIn:DisplayObject = container.getChildAt(1);		//	fadeMeIn.alpha=1;			TweenLite.to(fadeMeIn, 1.5, {alpha:1}); 		}						private function addMCQuestion():void{							trace("GET A Q MC 3 :: "+ sNum +" :: "+qNum);				if(container.contains(MC_Q)){					removeChild(MC_Q);									}				if(container.contains(TF_Q)){					container.removeChild(TF_Q);				}										container.addChild(MC_Q);				HOTCLIP= MC_Q;								MC_Q.alpha=0;				MC_Q.x = 90;				MC_Q.y = 147;				// set the question				MC_Q.question_tf.text = _quizArray[sNum].q_Arr[qNum].q_text;								// get number of answers				var aLen =  _quizArray[sNum].q_Arr[qNum].q_choicearray.length; // // 				MC_Q.ans_a_b.visible=true;				MC_Q.ans_b_b.visible=true;				MC_Q.ans_c_b.visible=true;				MC_Q.ans_d_b.visible=true;			//	trace("HEY "+MC_Q.ans_a_b.answer_tf);				// set the answers				// set the answer events				// set correct status				trace(_quizArray[sNum].q_Arr[qNum].q_choicearray[1].answer);									MC_Q.ans_a_b.answer_tf.htmlText = _quizArray[sNum].q_Arr[qNum].q_choicearray[0].answer;				// 	trace("GET A Q MC" + _quizArray[sNum].q_Arr[qNum].q_choicearray[0].answer);					MC_Q.ans_a_b.CORRECT = _quizArray[sNum].q_Arr[qNum].q_choicearray[0].surveysays;											setEvents(MC_Q.ans_a_b);					MC_Q.ans_b_b.answer_tf.htmlText = _quizArray[sNum].q_Arr[qNum].q_choicearray[1].answer;					MC_Q.ans_b_b.CORRECT = _quizArray[sNum].q_Arr[qNum].q_choicearray[1].surveysays;					setEvents(MC_Q.ans_b_b);						if(aLen >2){								MC_Q.ans_c_b.answer_tf.htmlText = _quizArray[sNum].q_Arr[qNum].q_choicearray[2].answer;								MC_Q.ans_c_b.CORRECT = _quizArray[sNum].q_Arr[qNum].q_choicearray[2].surveysays;								setEvents(MC_Q.ans_c_b);						}else{							MC_Q.ans_c_b.visible=false;							MC_Q.ans_d_b.visible=false;						}						if(aLen >3){							MC_Q.ans_d_b.answer_tf.htmlText = _quizArray[sNum].q_Arr[qNum].q_choicearray[3].answer;							MC_Q.ans_d_b.CORRECT = _quizArray[sNum].q_Arr[qNum].q_choicearray[3].surveysays;							setEvents(MC_Q.ans_d_b);						}else{							MC_Q.ans_d_b.visible=false;						}									// run through all choices and grab CORRECT VERSION				for(var v=0;v<4;v++){					if(_quizArray[sNum].q_Arr[qNum].q_choicearray[v].surveysays == "true"){						HOLD_CORRECT_ANSWER = _quizArray[sNum].q_Arr[qNum].q_choicearray[v].answer;						trace("THIS IS THE CORRECT ONE >> "+HOLD_CORRECT_ANSWER)					}				}																						}						private function setEvents(clip):void{			clip.addEventListener(MouseEvent.CLICK, aHandler);		 	clip.addEventListener(MouseEvent.MOUSE_OUT, aMouseOutHandler);		 	clip.addEventListener(MouseEvent.MOUSE_OVER, aMouseOverHandler);			clip.mouseChildren = false;		}				private function aHandler(e:Event):void{			if(QUESTIONTYPE=="MC"){				trace(e.target.answer_tf.text);				HOLD_CLICKED_ANSWER = e.target.answer_tf.text;			}else if(QUESTIONTYPE=="TF"){				trace( e.target.CORRECT.toString());				HOLD_CLICKED_ANSWER =  e.target.CORRECT.toString();			}			checkTruth(e.target);		}	 		private function aMouseOutHandler(e:Event):void{				//e.target.bkg.alpha=0;				TweenLite.to(e.target.bkg, 0.25, {alpha:0}); 							}			private function aMouseOverHandler(e:Event):void{				//e.target.gotoAndPlay("out");				TweenLite.to(e.target.bkg, 0.25, {alpha:1}); 							}					private function removeEvents(clip):void{			clip.removeEventListener(MouseEvent.CLICK, aHandler);		 //	clip.removeEventListener(MouseEvent.MOUSE_OUT, aMouseOutHandler);		//	clip.removeEventListener(MouseEvent.MOUSE_OVER, aMouseOverHandler);		}								private function checkTruth(clip):void{			trace("CHECK TRUTH PLEASE :: "+typeof clip);						if(clip.CORRECT =="true"){				trace("TRUE DUDE");					correctResult();			}else if(clip.CORRECT =="false"){				trace("FALSE DUDE");					incorrectResult();			}else{				trace("WHAT HAPPENED??");			}		}					private function correctResult():void{			trace(HOTCLIP.chosen_answer_tf+""+HOLD_CLICKED_ANSWER) 	 	 switch(QUESTIONTYPE){				case "MC" :						HOTCLIP.gotoAndStop("correct");					with(HOTCLIP){						chosen_answer.chosen_answer_tf.htmlText = HOLD_CLICKED_ANSWER;						chosen_answer.alpha=1;						continue_button.alpha=1;						continue_button.buttonMode=true;						continue_button.useHandCursor=true;					}				break;							case "TF" :				break;							default:					trace("ERROR :: TF OR MC ??")				break;						}									}					private function incorrectResult():void{				var clip = container.getChildAt(0);							switch(QUESTIONTYPE){					case "MC" :					HOTCLIP.gotoAndStop("incorrect");											with(HOTCLIP){							chosen_answer.chosen_answer_tf.htmlText = HOLD_CLICKED_ANSWER;							chosen_answer.alpha=1;							wrongheader.alpha=1;													chosen_answer.correct_answer.htmlText = HOLD_CORRECT_ANSWER;							chosen_answer.alpha=1;																			continue_button.alpha=1;							continue_button.buttonMode=true;							continue_button.useHandCursor=true;						}					break;									case "TF" :						//TF_correction					break;									default:						trace("ERROR :: TF OR MC ??")					break;								}					}					} // end class} // end package